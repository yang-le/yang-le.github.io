@[TOC](项和类型)

# Quest 0 - 项和类型

<!--
```agda
module Trinitarianism.Quest0 where

open import Cubical.Core.Everything hiding (_∨_) public
```
-->

看待 `A : Type`有三种角度。
- 证明论的角度，“`A` 是一个命题”
- 类型论的角度，“`A` 是一个构造”
- 几何/范畴论的角度，“`A` 是一个空间，`Type` 是空间的范畴”

第一个类型构造的例子是函数类型。给定类型 `A : Type` 和 `B : Type`, 我们有另一个类型 `A → B : Type` 可被视为
- 命题“`A` 蕴含 `B`”
- 将 `A` 的配方转换为 `B` 的配方的构造方法
- 从 `A` 到 `B` 的映射的空间，即从 `A` 到 `B` 的映射对应于 `A → B` 中的点
- 范畴 `Type` 的internal hom

为了给出具体的例子，我们先定义一些类型。

## True / Unit / 终对象

```agda
data ⊤ : Type where
  tt : ⊤
```
这读作“`⊤` 是一个带构造子 `tt` 的归纳类型”，可解释为
- `⊤` 是命题“真”且有一个关于它的证明，叫做 `tt`
- `⊤` 是构造“顶”且有一个关于它的配方，叫做 `tt`
- `⊤` 是单例空间
- `⊤` 是终对象：每一个对象都有一个到 `⊤` 的态射 `· ↦ tt`

一般来说，表达式 `a : A` 读作“`a` 是类型 `A` 的项”，可解释为
- `a` 是命题 `A` 的证明
- `a` 是构造 `A` 的配方
- `a` 是空间 `A` 中的点
- `a` 是对象 `A` 在范畴 `Type` 中的广义元素

以上告诉我们如何*构造*类型 `⊤` 的项。让我们看一个*使用*类型 `⊤` 的项的例子。

```agda
TrueToTrue : ⊤ → ⊤
TrueToTrue = λ x → x

TrueToTrue' : ⊤ → ⊤
TrueToTrue' tt = tt
```
定义 `⊤` 中内置了 `agda` 可用以构造从 `⊤` 到另一类型 `A` 的映射的方法，我们刚已经用过了。即要构造从 `⊤` 发出的映射，只需考虑当 `x` 是 `tt` 这一种情形，换言之
- `⊤` 的唯一证明是 `tt`
- `⊤` 的唯一配方是 `tt`
- `⊤` 空间中的唯一点是 `tt`
- `⊤` 中唯一的广义元素是 `tt`

让我们定义另一个类型。

## False / Empty / 始对象

```agda
data ⊥ : Type where
```
这读作 `⊥` 是一个不带构造子的归纳类型，可解释为
- `⊥` 是命题“假”，没有证明
- `⊥` 是构造“底”，没有配方
- `⊥` 是空的空间
- `⊥` 没有广义元素（是一个严格的始对象）

我们可以从 `⊥` 构造到任何其他类型的映射，特别是到 `⊤` 的。

```agda
explosion : ⊥ → ⊤
explosion ()
```
`agda` 知道无需考虑任何情形，因此无事可做。我们对此的解释为
- “假”蕴含“真”。实际上，同样的证明给出“假”蕴含任何东西（爆炸原理）。
- 我们可以将 `⊥` 的配方转换为 `⊤` 的配方。实际上同样的构造给出任何其他构造的配方，因为根本就没有 `⊥` 的配方。
- 存在从空的空间到单例空间的映射。实际上，给定任何空间 `A`, 存在从空的空间到 `A` 的映射。
- `⊥` 有一个到 `⊤` 的映射。这是由于 `⊥` 在范畴 `Type` 中的初始性。

## 自然数

我们可以编码“自然数”为下面的类型。

```agda
data ℕ : Type where
  zero : ℕ
  suc : ℕ → ℕ
```

我们解释如下：
- `ℕ` 没有作为命题的解释，因为存在“太多证明” ——
  传统上数学家不区分针对单个命题的证明。（ZFC甚至不会在内部提及逻辑，但类型论会。）在这个意义下构造是*证明相关*的类型。
- 作为构造：
  - `ℕ` 是构造的类型
  - `zero` 是 `ℕ` 的配方
  - `suc` 接受一个 `ℕ` 的既存配方，给出 `ℕ` 的另一个配方
- 范畴论的角度：`ℕ` 是范畴 `Type` 中的[自然数对象](https://www.zhihu.com/question/609503563/answer/3107267809)。这意味着它自带态射 `zero : ⊤ → ℕ` 和 `suc : ℕ → ℕ` 满足对任意给定的 `⊤ → A → A` 都存在一个唯一的态射 `ℕ → A` 使得下图交换：
<script type="text/tikz">
  \usepackage{amsfonts}
  \usetikzlibrary{cd}
  \begin{document}
  \begin{tikzcd}
  \top \arrow[d] \arrow[r, "\mathrm{zero}"] & \mathbb N \arrow[d] \arrow[r, "\mathrm{suc}"] & \mathbb N \arrow[d] \\
  \top \arrow[r, "a_0"']           & A \arrow[r, "a_{\mathrm{suc}}"']      & A          
  \end{tikzcd}
  \end{document}
</script>
- 几何角度：`ℕ` 是带有一个点 `zero` 的空间，且对每一个 `ℕ` 中的点 `n`, 存在另一个点 `suc n` 也在 `ℕ` 中。

要了解如何使用类型 `ℕ` 的项，比如在 `ℕ` 上归纳，请转到 [Quest 1 - 依赖类型](?article=hott_game/Trinitarianism/Quest1.lagda)。

## 宇宙

你可能已经注意到了记号 `zero : ℕ` 和 `ℕ : Type` 之间的相似性。类型 `Type` 有如下解释：
- 作为构造：任何构造的类型是 `Type` 的配方
- 几何观点：`Type` 是空间的空间。`Type` 中每个单独的点是一个空间。

这可能引起你的疑问，`Type : ?`。在类型论中，我们简单地断言 `Type : Type₁`。但这样我们就得一直这样定义下去，要求 `Type₁ : Type₂`。类型论学者确保每个类型（即`:`右边的东西）本身是一个项（即`:`左边的东西），且每个项都有一个类型。所以实际上我们需要的是

    Type : Type₁, Type₁ : Type₂, Type₂ : Type₃, ⋯

这些被称为*宇宙*。宇宙的编号称为*等级*。将类型视作项是十分关键的。这将允许我们
- 谈及谓词，即“依赖于变量的命题”。例如，命题“`n` 是偶数”依赖于自然数 `n`。请见下一关，那里我们将细化这个例子。
- 推理“结构”，例如“群的结构”，来表达“对所有的群，……”
- 研究范畴论而无需跳出理论本身。（对于专家，我们有Grothendieck宇宙。）
- 推理什么时候两个类型是“相同的”，例如什么时候关于自然数的两个定义是“相同的”？什么是“相同”？
